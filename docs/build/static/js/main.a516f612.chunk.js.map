{"version":3,"sources":["config/const.js","components/Board.js","components/Button.js","components/Start.js","components/Result.js","utils/sumCoordinates.js","utils/playerCanChangeToDirection.js","utils/getCellKey.js","App.js","utils/getPlayableCells.js","hooks/useInterval.js","index.js"],"names":["DIRECTIONS","LEFT","x","y","RIGHT","UP","DOWN","PLAYER_ONE","color","id","keys","38","39","40","37","direction","position","UNIT","hasDied","instructions","PLAYER_TWO","87","68","83","65","Board","players","gameStatus","canvasRef","useRef","useEffect","context","current","getContext","clearRect","beginPath","strokeStyle","i","moveTo","lineTo","stroke","closePath","forEach","player","fillStyle","fillRect","ref","width","height","className","map","style","key","href","alt","Button","children","onClick","Start","Result","result","sumCoordinates","coordA","coordB","Object","reduce","positionObject","coordinate","playerCanChangeToDirection","currentDirection","nextDirection","filter","length","getCellKey","initialState","playableCells","boardSize","cellSize","initialPositionPlayers","j","cellKey","includes","push","getPlayableCells","updateGame","game","action","type","newPlayers","newPlayersWithCollision","myCellKey","p","newOcupiedCells","playableCell","App","useReducer","gameDispatch","handleStart","handleRestart","callback","delay","savedCallback","setInterval","clearInterval","useInterval","handleKeyPress","event","keyCode","document","addEventListener","removeEventListener","winningPlayers","join","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.a516f612.chunk.js","sourcesContent":["export const UNIT = 15; //define tama침o de la nave\nexport const BOARD_SIZE = 750; //define tama침o del tablero\n\n\n\n//constantes para ver el estado inicial del juego\nexport const GAME_READY = 1;\nexport const GAME_PLAYING = 2;\nexport const GAME_ENDED = 3;\n\n\n\n\n//objeto que va a almacenar las direcciones y la forma en que hay que actualizar la posici칩n\nexport const DIRECTIONS = {\n  LEFT: { x: -UNIT, y: 0 },\n  RIGHT: { x: UNIT, y: 0 },\n  UP: { x: 0, y: -UNIT },\n  DOWN: { x: 0, y: UNIT },\n};\n\nexport const PLAYER_ONE = {\n  //definimos jugador 1\n  color: '#AB1091',\n  id: '1',\n  keys: {\n    38: DIRECTIONS.UP,\n    39: DIRECTIONS.RIGHT,\n    40: DIRECTIONS.DOWN,\n    37: DIRECTIONS.LEFT,\n  },\n  direction: DIRECTIONS.RIGHT,\n  position: { x: UNIT * 6, y: UNIT * 6 },\n  hasDied: false,\n  instructions: 'Usa las flechas de direcci칩n'\n};\n\nexport const PLAYER_TWO = {\n  //definimos jugador 2\n  color: '#0000CC',\n  id: '2',\n  keys: {\n    87: DIRECTIONS.UP,\n    68: DIRECTIONS.RIGHT,\n    83: DIRECTIONS.DOWN,\n    65: DIRECTIONS.LEFT,\n  },\n  direction: DIRECTIONS.LEFT,\n  position: { x: UNIT * 43, y: UNIT * 43 },\n  hasDied: false,\n  instructions: 'Usa las teclas AWSD'\n};\n","import React, { useEffect, useRef, Fragment } from 'react';\nimport { UNIT, BOARD_SIZE, GAME_READY } from 'config/const';\n\nfunction Board({ players, gameStatus }) {\n  const canvasRef = useRef();\n\n  //dibujamos grid\n  useEffect(\n    function () {\n      if (gameStatus === GAME_READY) {\n        const canvas = canvasRef.current;\n        const context = canvas.getContext('2d');\n        context.clearRect(0, 0, BOARD_SIZE, BOARD_SIZE);\n\n        context.beginPath();\n        context.strokeStyle = '#001900';\n        for (let i = UNIT * 2; i <= BOARD_SIZE; i += UNIT * 2) {\n          context.moveTo(i, 0);\n          context.lineTo(i, BOARD_SIZE);\n        }\n        for (let i = UNIT * 2; i <= BOARD_SIZE; i += UNIT * 2) {\n          context.moveTo(0, i);\n          context.lineTo(BOARD_SIZE, i);\n        }\n\n        context.stroke();\n        context.closePath();\n      }\n    },\n    [gameStatus]\n  );\n\n  //pintamos los jugadores\n\n  useEffect(\n    function () {\n      const context = canvasRef.current.getContext('2d');\n      players.forEach((player) => {\n        context.fillStyle = player.color;\n        context.fillRect(player.position.x, player.position.y, UNIT, UNIT);\n      });\n    },\n    [players]\n  );\n\n  return (\n    <Fragment>\n      <canvas\n        ref={canvasRef}\n        id=\"board\"\n        width={BOARD_SIZE}\n        height={BOARD_SIZE}\n        className=\"board\"\n      />\n      <div className=\"instructions\">\n        {players.map((player) => (\n          <div\n            className=\"instructions__player\"\n            style={{ color: player.color }}\n            key={`player--${player.id}`}\n          >\n            {`${player.id}: ${player.instructions}`}\n          </div>\n        ))}\n      </div>\n      <a\n        href=\"https://github.com/laugeeme\"\n        alt=\"laugeeme\"\n        className=\"signature\"\n      >\n        By laugeeme\n      </a>\n    </Fragment>\n  );\n}\n\nexport default Board;\n","import React from 'react';\n\nfunction Button({ children, onClick }) {\n  return (\n    <button className=\"button\" onClick={onClick}>\n      {children}\n    </button>\n  );\n}\n\nexport default Button;\n","import React from 'react';\nimport Button from 'components/Button';\n\nfunction Start({ onClick }) {\n  return (\n    <div className=\"play-info\">\n      {' '}\n      <Button onClick={onClick}>Comenzar</Button>\n    </div>\n  );\n}\n\nexport default Start;\n","import React from 'react';\nimport Button from './Button';\n\nfunction Result({ result, onClick }) {\n  return (\n    <div className=\"play-info\">\n      <h1>{result}</h1>\n      <Button onClick={onClick}>Volver a jugar</Button>\n    </div>\n  );\n}\n\nexport default Result;\n","export default function sumCoordinates(coordA, coordB) {\n  return Object.keys(coordA).reduce(\n    (positionObject, coordinate) => ({\n      ...positionObject,\n      [coordinate]: coordA[coordinate] + coordB[coordinate],\n    }),\n    {}\n  );\n}\n","import sumCoordinates from 'utils/sumCoordinates';\n\n\n//funci칩n para que si la suma de las coordenadas sea 0 no lo permita, no deja cambiar de direcci칩n para retroceder.\nexport default function playerCanChangeToDirection(\n  currentDirection,\n  nextDirection\n) {\n  const result = sumCoordinates(currentDirection, nextDirection);\n  return (\n    Object.keys(result).filter((coordinate) => result[coordinate] !== 0)\n      .length > 0\n  );\n}\n","export default function getCellKey(x,y){\n  return `${x}${y}`;\n}","import React, { useEffect, useReducer, Fragment } from 'react';\nimport './App.css';\nimport Board from 'components/Board';\nimport Start from 'components/Start';\nimport Result from 'components/Result';\nimport {\n  BOARD_SIZE,\n  GAME_ENDED,\n  GAME_PLAYING,\n  GAME_READY,\n  PLAYER_ONE,\n  PLAYER_TWO,\n  UNIT,\n} from 'config/const';\nimport useInterval from 'hooks/useInterval';\nimport sumCoordinates from 'utils/sumCoordinates';\nimport playerCanChangeToDirection from 'utils/playerCanChangeToDirection';\nimport getPlayableCells from 'utils/getPlayableCells';\nimport getCellKey from './utils/getCellKey';\n\nconst players = [PLAYER_ONE, PLAYER_TWO];\n\nconst initialState = {\n  //en el estado inicial no est치 solo los jugadores, sino las celdas jugables\n  players,\n  playableCells: getPlayableCells(\n    BOARD_SIZE,\n    UNIT,\n    players.map((player) => getCellKey(player.position.x, player.position.y))\n  ),\n  gameStatus: GAME_READY,\n};\n\nfunction updateGame(game, action) {\n  if (action.type === 'start') {\n    return {\n      ...initialState,\n      gameStatus: GAME_PLAYING,\n    };\n  }\n\n  if (action.type === 'restart') {\n    return {\n      ...initialState,\n      gameStatus: GAME_READY,\n    };\n  }\n\n  //calculamos primero la posici칩n de los nuevos jugadores\n  if (action.type === 'move') {\n    //actualizaci칩n del estado del jugador\n    const newPlayers = game.players.map((player) => ({\n      ...player,\n      position: sumCoordinates(player.position, player.direction),\n    }));\n\n    //actualizamos la posici칩n de los jugadores en base a hasDied, si ha muerto o no\n    const newPlayersWithCollision = newPlayers.map((player) => {\n      const myCellKey = getCellKey(player.position.x, player.position.y);\n      return {\n        ...player,\n        hasDied:\n          !game.playableCells.includes(myCellKey) ||\n          newPlayers\n            .filter((p) => p.id !== player.id)\n            .map((p) => getCellKey(p.position.x, p.position.y))\n            .includes(myCellKey),\n      };\n    });\n\n    //modificar las celdas que son jugables quitando las nuevas posiciones\n    const newOcupiedCells = game.players.map((player) =>\n      getCellKey(player.position.x, player.position.y)\n    );\n\n    const playableCells = game.playableCells.filter((playableCell) => {\n      return !newOcupiedCells.includes(playableCell);\n    });\n\n    return {\n      players: newPlayersWithCollision,\n      playableCells: playableCells,\n      gameStatus:\n        newPlayersWithCollision.filter((player) => player.hasDied).length === 0\n          ? GAME_PLAYING\n          : GAME_ENDED,\n    };\n  }\n  if (action.type === 'changeDirection') {\n    const newPlayers = game.players.map((player) => ({\n      ...player,\n      direction:\n        player.keys[action.key] &&\n        playerCanChangeToDirection(player.direction, player.keys[action.key])\n          ? player.keys[action.key]\n          : player.direction,\n    }));\n    return {\n      players: newPlayers,\n      playableCells: game.playableCells,\n      gameStatus: game.gameStatus,\n    };\n  }\n}\n\nfunction App() {\n  let result = null;\n  const [game, gameDispatch] = useReducer(updateGame, initialState);\n\n  //creamos el contador cada vez que uno muera\n  const players = game.players;\n  const diedPlayers = players.filter((player) => player.hasDied);\n  if (diedPlayers.length > 0) {\n  }\n\n  useInterval(\n    function () {\n      gameDispatch({ type: 'move' });\n    },\n    game.gameStatus !== GAME_PLAYING ? null : 100 //si muere alguien (null) paramos el juego\n  );\n\n  //escuchamos el evento de la escucha de teclas, solo para la primera vez, no queremos que lo haga cada vez que renderice, por eso luego hacemos un cleanup.\n  useEffect(\n    function () {\n      function handleKeyPress(event) {\n        const key = `${event.keyCode}`;\n        if (key === '13') {\n          if (game.gameStatus === GAME_READY) {\n            handleStart();\n          }\n          if (game.gameStatus === GAME_ENDED) {\n            handleRestart();\n          }\n        }\n        gameDispatch({ type: 'changeDirection', key });\n      }\n\n      document.addEventListener('keydown', handleKeyPress);\n\n      return function cleanUp() {\n        document.removeEventListener('keydown', handleKeyPress);\n      };\n    },\n    [game.gameStatus]\n  );\n\n  function handleStart() {\n    gameDispatch({ type: 'start' });\n  }\n\n  function handleRestart() {\n    gameDispatch({ type: 'restart' });\n  }\n\n  if (game.gameStatus === GAME_ENDED) {\n    const winningPlayers = game.players.filter((player) => !player.hasDied);\n    if (winningPlayers.length === 0) {\n      result = 'Empate';\n    } else {\n      result = `Ganador: ${winningPlayers\n        .map((player) => `Jugador ${player.id}`)\n        .join('.')}`;\n    }\n  }\n\n  return (\n    <Fragment>\n      <Board players={game.players} gameStatus={game.gameStatus} />\n      {game.gameStatus === GAME_ENDED && (\n        <Result onClick={handleRestart} result={result} />\n      )}\n      {game.gameStatus === GAME_READY && <Start onClick={handleStart} />}\n    </Fragment>\n  );\n}\n\nexport default App;\n","//funci칩n para ver cuales son las celdas vac칤as a las que puede acceder la nave\nimport getCellKey from 'utils/getCellKey';\n\nexport default function getPlayableCells(\n  boardSize,\n  cellSize,\n  initialPositionPlayers\n) {\n  const playableCells = [];\n  for (let i = 0; i < boardSize / cellSize; i++) {\n    for (let j = 0; j < boardSize / cellSize; j++) {\n      const cellKey = getCellKey(i * cellSize, j * cellSize);\n      if (!initialPositionPlayers.includes(cellKey)) {\n        playableCells.push(cellKey);\n      }\n    }\n  }\n\n  return playableCells;\n}\n","import { useEffect, useRef } from 'react';\n\nexport default function useInterval(callback, delay) {\n  const savedCallback = useRef();\n\n  // Remember the latest callback.\n  useEffect(() => {\n    savedCallback.current = callback;\n  }, [callback]);\n\n  // Set up the interval.\n  useEffect(() => {\n    function tick() {\n      savedCallback.current();\n    }\n    if (delay !== null) {\n      let id = setInterval(tick, delay);\n      return () => clearInterval(id);\n    }\n  }, [delay]);\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}