{"version":3,"sources":["config/const.js","components/Board.js","components/Button.js","components/Start.js","components/Result.js","utils/sumCoordinates.js","utils/playerCanChangeToDirection.js","utils/getCellKey.js","App.js","utils/getPlayableCells.js","hooks/useInterval.js","index.js"],"names":["DIRECTIONS","LEFT","x","y","RIGHT","UP","DOWN","PLAYER_ONE","color","id","keys","38","39","40","37","direction","position","UNIT","hasDied","instructions","PLAYER_TWO","87","68","83","65","Board","players","gameStatus","canvasRef","useRef","useEffect","context","current","getContext","clearRect","beginPath","strokeStyle","i","moveTo","lineTo","stroke","closePath","forEach","player","fillStyle","fillRect","ref","width","height","className","map","style","key","href","alt","Button","children","onClick","Start","Result","result","sumCoordinates","coordA","coordB","Object","reduce","positionObject","coordinate","playerCanChangeToDirection","currentDirection","nextDirection","filter","length","getCellKey","initialState","playableCells","boardSize","cellSize","initialPositionPlayers","j","cellKey","includes","push","getPlayableCells","updateGame","game","action","type","newPlayers","newPlayersWithCollision","myCellKey","p","newOcupiedCells","playableCell","App","useReducer","gameDispatch","handleStart","handleRestart","callback","delay","savedCallback","setInterval","clearInterval","useInterval","handleKeyPress","event","keyCode","document","addEventListener","removeEventListener","winningPlayers","join","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.a516f612.chunk.js","sourcesContent":["export const UNIT = 15; //define tamaño de la nave\nexport const BOARD_SIZE = 750; //define tamaño del tablero\n\n\n\n//constantes para ver el estado inicial del juego\nexport const GAME_READY = 1;\nexport const GAME_PLAYING = 2;\nexport const GAME_ENDED = 3;\n\n\n\n\n//objeto que va a almacenar las direcciones y la forma en que hay que actualizar la posición\nexport const DIRECTIONS = {\n  LEFT: { x: -UNIT, y: 0 },\n  RIGHT: { x: UNIT, y: 0 },\n  UP: { x: 0, y: -UNIT },\n  DOWN: { x: 0, y: UNIT },\n};\n\nexport const PLAYER_ONE = {\n  //definimos jugador 1\n  color: '#AB1091',\n  id: '1',\n  keys: {\n    38: DIRECTIONS.UP,\n    39: DIRECTIONS.RIGHT,\n    40: DIRECTIONS.DOWN,\n    37: DIRECTIONS.LEFT,\n  },\n  direction: DIRECTIONS.RIGHT,\n  position: { x: UNIT * 6, y: UNIT * 6 },\n  hasDied: false,\n  instructions: 'Usa las flechas de dirección'\n};\n\nexport const PLAYER_TWO = {\n  //definimos jugador 2\n  color: '#0000CC',\n  id: '2',\n  keys: {\n    87: DIRECTIONS.UP,\n    68: DIRECTIONS.RIGHT,\n    83: DIRECTIONS.DOWN,\n    65: DIRECTIONS.LEFT,\n  },\n  direction: DIRECTIONS.LEFT,\n  position: { x: UNIT * 43, y: UNIT * 43 },\n  hasDied: false,\n  instructions: 'Usa las teclas AWSD'\n};\n","import React, { useEffect, useRef, Fragment } from 'react';\nimport { UNIT, BOARD_SIZE, GAME_READY } from 'config/const';\n\nfunction Board({ players, gameStatus }) {\n  const canvasRef = useRef();\n\n  //dibujamos grid\n  useEffect(\n    function () {\n      if (gameStatus === GAME_READY) {\n        const canvas = canvasRef.current;\n        const context = canvas.getContext('2d');\n        context.clearRect(0, 0, BOARD_SIZE, BOARD_SIZE);\n\n        context.beginPath();\n        context.strokeStyle = '#001900';\n        for (let i = UNIT * 2; i <= BOARD_SIZE; i += UNIT * 2) {\n          context.moveTo(i, 0);\n          context.lineTo(i, BOARD_SIZE);\n        }\n        for (let i = UNIT * 2; i <= BOARD_SIZE; i += UNIT * 2) {\n          context.moveTo(0, i);\n          context.lineTo(BOARD_SIZE, i);\n        }\n\n        context.stroke();\n        context.closePath();\n      }\n    },\n    [gameStatus]\n  );\n\n  //pintamos los jugadores\n\n  useEffect(\n    function () {\n      const context = canvasRef.current.getContext('2d');\n      players.forEach((player) => {\n        context.fillStyle = player.color;\n        context.fillRect(player.position.x, player.position.y, UNIT, UNIT);\n      });\n    },\n    [players]\n  );\n\n  return (\n    <Fragment>\n      <canvas\n        ref={canvasRef}\n        id=\"board\"\n        width={BOARD_SIZE}\n        height={BOARD_SIZE}\n        className=\"board\"\n      />\n      <div className=\"instructions\">\n        {players.map((player) => (\n          <div\n            className=\"instructions__player\"\n            style={{ color: player.color }}\n            key={`player--${player.id}`}\n          >\n            {`${player.id}: ${player.instructions}`}\n          </div>\n        ))}\n      </div>\n      <a\n        href=\"https://github.com/laugeeme\"\n        alt=\"laugeeme\"\n        className=\"signature\"\n      >\n        By laugeeme\n      </a>\n    </Fragment>\n  );\n}\n\nexport default Board;\n","import React from 'react';\n\nfunction Button({ children, onClick }) {\n  return (\n    <button className=\"button\" onClick={onClick}>\n      {children}\n    </button>\n  );\n}\n\nexport default Button;\n","import React from 'react';\nimport Button from 'components/Button';\n\nfunction Start({ onClick }) {\n  return (\n    <div className=\"play-info\">\n      {' '}\n      <Button onClick={onClick}>Comenzar</Button>\n    </div>\n  );\n}\n\nexport default Start;\n","import React from 'react';\nimport Button from './Button';\n\nfunction Result({ result, onClick }) {\n  return (\n    <div className=\"play-info\">\n      <h1>{result}</h1>\n      <Button onClick={onClick}>Volver a jugar</Button>\n    </div>\n  );\n}\n\nexport default Result;\n","export default function sumCoordinates(coordA, coordB) {\n  return Object.keys(coordA).reduce(\n    (positionObject, coordinate) => ({\n      ...positionObject,\n      [coordinate]: coordA[coordinate] + coordB[coordinate],\n    }),\n    {}\n  );\n}\n","import sumCoordinates from 'utils/sumCoordinates';\n\n\n//función para que si la suma de las coordenadas sea 0 no lo permita, no deja cambiar de dirección para retroceder.\nexport default function playerCanChangeToDirection(\n  currentDirection,\n  nextDirection\n) {\n  const result = sumCoordinates(currentDirection, nextDirection);\n  return (\n    Object.keys(result).filter((coordinate) => result[coordinate] !== 0)\n      .length > 0\n  );\n}\n","export default function getCellKey(x,y){\n  return `${x}${y}`;\n}","import React, { useEffect, useReducer, Fragment } from 'react';\nimport './App.css';\nimport Board from 'components/Board';\nimport Start from 'components/Start';\nimport Result from 'components/Result';\nimport {\n  BOARD_SIZE,\n  GAME_ENDED,\n  GAME_PLAYING,\n  GAME_READY,\n  PLAYER_ONE,\n  PLAYER_TWO,\n  UNIT,\n} from 'config/const';\nimport useInterval from 'hooks/useInterval';\nimport sumCoordinates from 'utils/sumCoordinates';\nimport playerCanChangeToDirection from 'utils/playerCanChangeToDirection';\nimport getPlayableCells from 'utils/getPlayableCells';\nimport getCellKey from './utils/getCellKey';\n\nconst players = [PLAYER_ONE, PLAYER_TWO];\n\nconst initialState = {\n  //en el estado inicial no está solo los jugadores, sino las celdas jugables\n  players,\n  playableCells: getPlayableCells(\n    BOARD_SIZE,\n    UNIT,\n    players.map((player) => getCellKey(player.position.x, player.position.y))\n  ),\n  gameStatus: GAME_READY,\n};\n\nfunction updateGame(game, action) {\n  if (action.type === 'start') {\n    return {\n      ...initialState,\n      gameStatus: GAME_PLAYING,\n    };\n  }\n\n  if (action.type === 'restart') {\n    return {\n      ...initialState,\n      gameStatus: GAME_READY,\n    };\n  }\n\n  //calculamos primero la posición de los nuevos jugadores\n  if (action.type === 'move') {\n    //actualización del estado del jugador\n    const newPlayers = game.players.map((player) => ({\n      ...player,\n      position: sumCoordinates(player.position, player.direction),\n    }));\n\n    //actualizamos la posición de los jugadores en base a hasDied, si ha muerto o no\n    const newPlayersWithCollision = newPlayers.map((player) => {\n      const myCellKey = getCellKey(player.position.x, player.position.y);\n      return {\n        ...player,\n        hasDied:\n          !game.playableCells.includes(myCellKey) ||\n          newPlayers\n            .filter((p) => p.id !== player.id)\n            .map((p) => getCellKey(p.position.x, p.position.y))\n            .includes(myCellKey),\n      };\n    });\n\n    //modificar las celdas que son jugables quitando las nuevas posiciones\n    const newOcupiedCells = game.players.map((player) =>\n      getCellKey(player.position.x, player.position.y)\n    );\n\n    const playableCells = game.playableCells.filter((playableCell) => {\n      return !newOcupiedCells.includes(playableCell);\n    });\n\n    return {\n      players: newPlayersWithCollision,\n      playableCells: playableCells,\n      gameStatus:\n        newPlayersWithCollision.filter((player) => player.hasDied).length === 0\n          ? GAME_PLAYING\n          : GAME_ENDED,\n    };\n  }\n  if (action.type === 'changeDirection') {\n    const newPlayers = game.players.map((player) => ({\n      ...player,\n      direction:\n        player.keys[action.key] &&\n        playerCanChangeToDirection(player.direction, player.keys[action.key])\n          ? player.keys[action.key]\n          : player.direction,\n    }));\n    return {\n      players: newPlayers,\n      playableCells: game.playableCells,\n      gameStatus: game.gameStatus,\n    };\n  }\n}\n\nfunction App() {\n  let result = null;\n  const [game, gameDispatch] = useReducer(updateGame, initialState);\n\n  //creamos el contador cada vez que uno muera\n  const players = game.players;\n  const diedPlayers = players.filter((player) => player.hasDied);\n  if (diedPlayers.length > 0) {\n  }\n\n  useInterval(\n    function () {\n      gameDispatch({ type: 'move' });\n    },\n    game.gameStatus !== GAME_PLAYING ? null : 100 //si muere alguien (null) paramos el juego\n  );\n\n  //escuchamos el evento de la escucha de teclas, solo para la primera vez, no queremos que lo haga cada vez que renderice, por eso luego hacemos un cleanup.\n  useEffect(\n    function () {\n      function handleKeyPress(event) {\n        const key = `${event.keyCode}`;\n        if (key === '13') {\n          if (game.gameStatus === GAME_READY) {\n            handleStart();\n          }\n          if (game.gameStatus === GAME_ENDED) {\n            handleRestart();\n          }\n        }\n        gameDispatch({ type: 'changeDirection', key });\n      }\n\n      document.addEventListener('keydown', handleKeyPress);\n\n      return function cleanUp() {\n        document.removeEventListener('keydown', handleKeyPress);\n      };\n    },\n    [game.gameStatus]\n  );\n\n  function handleStart() {\n    gameDispatch({ type: 'start' });\n  }\n\n  function handleRestart() {\n    gameDispatch({ type: 'restart' });\n  }\n\n  if (game.gameStatus === GAME_ENDED) {\n    const winningPlayers = game.players.filter((player) => !player.hasDied);\n    if (winningPlayers.length === 0) {\n      result = 'Empate';\n    } else {\n      result = `Ganador: ${winningPlayers\n        .map((player) => `Jugador ${player.id}`)\n        .join('.')}`;\n    }\n  }\n\n  return (\n    <Fragment>\n      <Board players={game.players} gameStatus={game.gameStatus} />\n      {game.gameStatus === GAME_ENDED && (\n        <Result onClick={handleRestart} result={result} />\n      )}\n      {game.gameStatus === GAME_READY && <Start onClick={handleStart} />}\n    </Fragment>\n  );\n}\n\nexport default App;\n","//función para ver cuales son las celdas vacías a las que puede acceder la nave\nimport getCellKey from 'utils/getCellKey';\n\nexport default function getPlayableCells(\n  boardSize,\n  cellSize,\n  initialPositionPlayers\n) {\n  const playableCells = [];\n  for (let i = 0; i < boardSize / cellSize; i++) {\n    for (let j = 0; j < boardSize / cellSize; j++) {\n      const cellKey = getCellKey(i * cellSize, j * cellSize);\n      if (!initialPositionPlayers.includes(cellKey)) {\n        playableCells.push(cellKey);\n      }\n    }\n  }\n\n  return playableCells;\n}\n","import { useEffect, useRef } from 'react';\n\nexport default function useInterval(callback, delay) {\n  const savedCallback = useRef();\n\n  // Remember the latest callback.\n  useEffect(() => {\n    savedCallback.current = callback;\n  }, [callback]);\n\n  // Set up the interval.\n  useEffect(() => {\n    function tick() {\n      savedCallback.current();\n    }\n    if (delay !== null) {\n      let id = setInterval(tick, delay);\n      return () => clearInterval(id);\n    }\n  }, [delay]);\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}